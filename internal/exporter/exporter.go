package exporter

import (
	"bufio"
	"fmt"
	"io"
	"strings"
	"time"

	"github.com/elliotjreed/database-anonymiser-minimiser/internal/anonymiser"
	"github.com/elliotjreed/database-anonymiser-minimiser/internal/config"
	"github.com/elliotjreed/database-anonymiser-minimiser/internal/database"
	"github.com/elliotjreed/database-anonymiser-minimiser/internal/fktracker"
	"github.com/elliotjreed/database-anonymiser-minimiser/internal/schema"
)

const (
	// DefaultBatchSize is the default number of rows per INSERT statement.
	DefaultBatchSize = 1000

	// BufferSize is the buffer size for writing (64KB).
	BufferSize = 64 * 1024
)

// Stats contains export statistics.
type Stats struct {
	TablesExported  int
	TablesTruncated int
	RowsExported    int64
}

// Exporter handles SQL dump generation.
type Exporter struct {
	driver     database.Driver
	anonymiser *anonymiser.Anonymiser
	config     *config.Config
	writer     *bufio.Writer
	verbose    bool
	batchSize  int
	dbType     string
	stats      Stats

	// FK integrity tracking
	fkTracker *fktracker.Tracker
	fkMap     map[string][]database.ForeignKey // table -> its foreign keys
	pkColumns map[string][]string              // table -> primary key columns
}

// Options configures the exporter behavior.
type Options struct {
	Verbose   bool
	BatchSize int
}

// New creates a new Exporter instance.
func New(driver database.Driver, anon *anonymiser.Anonymiser, cfg *config.Config, output io.Writer, opts Options) *Exporter {
	batchSize := opts.BatchSize
	if batchSize <= 0 {
		batchSize = DefaultBatchSize
	}

	return &Exporter{
		driver:     driver,
		anonymiser: anon,
		config:     cfg,
		writer:     bufio.NewWriterSize(output, BufferSize),
		verbose:    opts.Verbose,
		batchSize:  batchSize,
		dbType:     driver.GetDatabaseType(),
		fkTracker:  fktracker.NewTracker(),
		fkMap:      make(map[string][]database.ForeignKey),
		pkColumns:  make(map[string][]string),
	}
}

// Export performs the full database export.
func (e *Exporter) Export(tables []schema.TableInfo) error {
	// Load FK relationships if FK integrity is enabled for any table
	if err := e.loadFKRelationships(tables); err != nil {
		return fmt.Errorf("failed to load foreign key relationships: %w", err)
	}

	// Write header
	if err := e.writeHeader(); err != nil {
		return err
	}

	// Export each table
	for _, table := range tables {
		if e.verbose {
			fmt.Printf("Exporting table: %s\n", table.Name)
		}

		if err := e.exportTable(table); err != nil {
			return fmt.Errorf("failed to export table %s: %w", table.Name, err)
		}
	}

	// Write footer
	if err := e.writeFooter(); err != nil {
		return err
	}

	return e.writer.Flush()
}

// loadFKRelationships loads foreign key information and primary keys for tables.
func (e *Exporter) loadFKRelationships(tables []schema.TableInfo) error {
	// Check if FK integrity is enabled globally or for any table
	fkIntegrityEnabled := false
	if e.config.ForeignKeyIntegrity != nil && *e.config.ForeignKeyIntegrity {
		fkIntegrityEnabled = true
	}
	if !fkIntegrityEnabled {
		for _, table := range tables {
			if e.config.ShouldEnforceFKIntegrity(table.Name) {
				fkIntegrityEnabled = true
				break
			}
		}
	}

	if !fkIntegrityEnabled {
		return nil // No FK integrity needed
	}

	// Load all foreign keys
	fks, err := e.driver.GetForeignKeys()
	if err != nil {
		return fmt.Errorf("failed to get foreign keys: %w", err)
	}

	// Build FK map (table -> its foreign keys)
	for _, fk := range fks {
		e.fkMap[fk.Table] = append(e.fkMap[fk.Table], fk)
	}

	// Load primary keys for all tables
	for _, table := range tables {
		pkCols, err := e.driver.GetPrimaryKey(table.Name)
		if err != nil {
			return fmt.Errorf("failed to get primary key for table %s: %w", table.Name, err)
		}
		e.pkColumns[table.Name] = pkCols
	}

	if e.verbose && len(fks) > 0 {
		fmt.Printf("Loaded %d foreign key relationships for FK integrity enforcement\n", len(fks))
	}

	return nil
}

// writeHeader writes the SQL dump header.
func (e *Exporter) writeHeader() error {
	header := fmt.Sprintf(`-- Database Dump
-- Generated by dbmask
-- Date: %s
-- Database Type: %s

`, time.Now().Format(time.RFC3339), e.dbType)

	if _, err := e.writer.WriteString(header); err != nil {
		return err
	}

	// Database-specific settings
	switch e.dbType {
	case "mysql":
		mysqlHeader := `SET NAMES utf8mb4;
SET FOREIGN_KEY_CHECKS = 0;
SET SQL_MODE = 'NO_AUTO_VALUE_ON_ZERO';
SET AUTOCOMMIT = 0;
START TRANSACTION;

`
		if _, err := e.writer.WriteString(mysqlHeader); err != nil {
			return err
		}
	case "postgres":
		pgHeader := `SET client_encoding = 'UTF8';
SET standard_conforming_strings = on;
SET check_function_bodies = false;
SET client_min_messages = warning;

`
		if _, err := e.writer.WriteString(pgHeader); err != nil {
			return err
		}
	case "sqlite":
		sqliteHeader := `PRAGMA foreign_keys = OFF;

`
		if _, err := e.writer.WriteString(sqliteHeader); err != nil {
			return err
		}
	}

	return nil
}

// writeFooter writes the SQL dump footer.
func (e *Exporter) writeFooter() error {
	switch e.dbType {
	case "mysql":
		footer := `
COMMIT;
SET FOREIGN_KEY_CHECKS = 1;
`
		if _, err := e.writer.WriteString(footer); err != nil {
			return err
		}
	case "postgres":
		footer := `
-- End of dump
`
		if _, err := e.writer.WriteString(footer); err != nil {
			return err
		}
	case "sqlite":
		footer := `
PRAGMA foreign_keys = ON;
`
		if _, err := e.writer.WriteString(footer); err != nil {
			return err
		}
	}

	return nil
}

// exportTable exports a single table's schema and data.
func (e *Exporter) exportTable(table schema.TableInfo) error {
	// Write table header comment
	comment := fmt.Sprintf("\n--\n-- Table: %s\n--\n\n", table.Name)
	if _, err := e.writer.WriteString(comment); err != nil {
		return err
	}

	// Write DROP TABLE IF EXISTS
	dropStmt := e.getDropTableStatement(table.Name)
	if _, err := e.writer.WriteString(dropStmt + "\n\n"); err != nil {
		return err
	}

	// Write CREATE TABLE
	if _, err := e.writer.WriteString(table.CreateStmt + "\n\n"); err != nil {
		return err
	}

	// Track table export
	e.stats.TablesExported++

	// Check if table should be truncated
	if e.anonymiser.ShouldTruncate(table.Name) {
		if e.verbose {
			fmt.Printf("  Truncating table: %s (no data)\n", table.Name)
		}
		e.stats.TablesTruncated++
		return nil
	}

	// Get retain configuration
	retainCfg := e.anonymiser.GetRetainConfig(table.Name)
	if e.verbose {
		if retainCfg.IsDateBased() {
			fmt.Printf("  Retaining rows from %s where %s > %s\n",
				table.Name, retainCfg.ColumnName, retainCfg.AfterDate.Format("2006-01-02"))
		} else if retainCfg.IsCountBased() {
			fmt.Printf("  Retaining %d rows from: %s\n", retainCfg.Count, table.Name)
		}
	}

	// Build stream options from retain config
	streamOpts := database.StreamOptions{
		Limit:      retainCfg.Count,
		ColumnName: retainCfg.ColumnName,
		AfterDate:  retainCfg.AfterDate,
	}

	// Build FK filters if FK integrity is enabled for this table
	if e.config.ShouldEnforceFKIntegrity(table.Name) {
		fkFilters := e.buildFKFilters(table.Name)
		streamOpts.FKFilters = fkFilters

		if e.verbose && len(fkFilters) > 0 {
			fmt.Printf("  Applying %d FK filters for integrity enforcement\n", len(fkFilters))
		}
	}

	// Get column names
	columnNames := make([]string, len(table.Columns))
	for i, col := range table.Columns {
		columnNames[i] = col.Name
	}

	// Get primary key columns for tracking
	pkCols := e.pkColumns[table.Name]

	// Stream and export rows
	var batch []map[string]any
	var rowCount int64
	err := e.driver.StreamRows(table.Name, streamOpts, e.batchSize, func(rows []map[string]any) error {
		for _, row := range rows {
			// Apply anonymization
			anonRow := e.anonymiser.AnonymiseRow(table.Name, row)

			// Track primary key values for FK integrity (use anonymised values)
			for _, pkCol := range pkCols {
				if val, ok := anonRow[pkCol]; ok {
					e.fkTracker.RecordValue(table.Name, pkCol, val)
				}
			}

			batch = append(batch, anonRow)
			rowCount++

			// Write batch when full
			if len(batch) >= e.batchSize {
				if err := e.writeBatchInsert(table.Name, columnNames, batch); err != nil {
					return err
				}
				batch = nil
			}
		}
		return nil
	})
	e.stats.RowsExported += rowCount
	if err != nil {
		return err
	}

	// Write remaining rows
	if len(batch) > 0 {
		if err := e.writeBatchInsert(table.Name, columnNames, batch); err != nil {
			return err
		}
	}

	return nil
}

// getDropTableStatement returns the DROP TABLE statement for the database type.
func (e *Exporter) getDropTableStatement(tableName string) string {
	quotedName := e.driver.QuoteIdentifier(tableName)
	switch e.dbType {
	case "mysql":
		return fmt.Sprintf("DROP TABLE IF EXISTS %s;", quotedName)
	case "postgres":
		return fmt.Sprintf("DROP TABLE IF EXISTS %s CASCADE;", quotedName)
	case "sqlite":
		return fmt.Sprintf("DROP TABLE IF EXISTS %s;", quotedName)
	default:
		return fmt.Sprintf("DROP TABLE IF EXISTS %s;", quotedName)
	}
}

// writeBatchInsert writes a batch INSERT statement.
func (e *Exporter) writeBatchInsert(tableName string, columns []string, rows []map[string]any) error {
	if len(rows) == 0 {
		return nil
	}

	quotedTable := e.driver.QuoteIdentifier(tableName)
	quotedCols := make([]string, len(columns))
	for i, col := range columns {
		quotedCols[i] = e.driver.QuoteIdentifier(col)
	}

	// Build INSERT statement
	var sb strings.Builder
	sb.WriteString(fmt.Sprintf("INSERT INTO %s (%s) VALUES\n",
		quotedTable, strings.Join(quotedCols, ", ")))

	for i, row := range rows {
		if i > 0 {
			sb.WriteString(",\n")
		}

		values := make([]string, len(columns))
		for j, col := range columns {
			values[j] = e.formatValue(row[col])
		}

		sb.WriteString("(")
		sb.WriteString(strings.Join(values, ", "))
		sb.WriteString(")")
	}

	sb.WriteString(";\n")

	_, err := e.writer.WriteString(sb.String())
	return err
}

// formatValue formats a value for SQL insertion.
func (e *Exporter) formatValue(val any) string {
	if val == nil {
		return "NULL"
	}

	switch v := val.(type) {
	case bool:
		if v {
			return "1"
		}
		return "0"
	case int, int8, int16, int32, int64, uint, uint8, uint16, uint32, uint64:
		return fmt.Sprintf("%d", v)
	case float32, float64:
		return fmt.Sprintf("%v", v)
	case []byte:
		return e.escapeString(string(v))
	case string:
		return e.escapeString(v)
	case time.Time:
		return e.escapeString(v.Format("2006-01-02 15:04:05"))
	default:
		return e.escapeString(fmt.Sprintf("%v", v))
	}
}

// escapeString escapes a string for SQL.
func (e *Exporter) escapeString(s string) string {
	// Replace special characters
	s = strings.ReplaceAll(s, "\\", "\\\\")
	s = strings.ReplaceAll(s, "'", "''")
	s = strings.ReplaceAll(s, "\x00", "\\0")
	s = strings.ReplaceAll(s, "\n", "\\n")
	s = strings.ReplaceAll(s, "\r", "\\r")
	s = strings.ReplaceAll(s, "\x1a", "\\Z")

	return "'" + s + "'"
}

// GetStats returns the export statistics.
func (e *Exporter) GetStats() Stats {
	return e.stats
}

// buildFKFilters builds FK filters for a table based on exported parent table values.
func (e *Exporter) buildFKFilters(tableName string) []database.FKFilter {
	fks, ok := e.fkMap[tableName]
	if !ok {
		return nil
	}

	var filters []database.FKFilter
	for _, fk := range fks {
		// Skip self-referencing FKs (table references itself)
		if fk.ReferencedTable == tableName {
			continue
		}

		// Get exported values from the parent table
		allowedValues := e.fkTracker.GetExportedValues(fk.ReferencedTable, fk.ReferencedColumn)

		filter := database.FKFilter{
			Column:        fk.Column,
			AllowedValues: allowedValues,
			AllowNull:     true, // NULL FK values are always valid in SQL
		}

		filters = append(filters, filter)
	}

	return filters
}
